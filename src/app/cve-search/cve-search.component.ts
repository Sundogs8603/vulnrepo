import {AfterViewInit, Component, ViewChild, OnInit} from '@angular/core';
import {MatPaginator, MatPaginatorModule, PageEvent} from '@angular/material/paginator';
import {MatSort, MatSortModule} from '@angular/material/sort';
import {MatTableDataSource, MatTableModule} from '@angular/material/table';
import { UntypedFormControl } from '@angular/forms';
import { ApiService } from '../api.service';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, Subject, of, pipe, from, interval, merge, fromEvent } from 'rxjs';
import { concatMap, delay, mergeMap } from 'rxjs/operators';
import { MatSnackBar } from '@angular/material/snack-bar';

@Component({
  standalone: false,
  //imports: [],
  selector: 'app-cve-search',
  templateUrl: './cve-search.component.html',
  styleUrl: './cve-search.component.scss'
})
export class CveSearchComponent implements AfterViewInit, OnInit {

  displayedColumns: string[] = ['id', 'description', 'published', 'severity', 'cvss'];
  dataSource = new MatTableDataSource();
  searchinput = new UntypedFormControl();
  searchoption = new UntypedFormControl();
  selected = 'keyword';
  searchinputcpe = new UntypedFormControl();
  inprogress = false;
  notfound = false;
  totalitemsapi = 0;
  currentindex = 0;
  progressval = 0;
  default_returneditems = 2000;
  @ViewChild(MatPaginator) paginator: MatPaginator;
  @ViewChild(MatSort) sort: MatSort;
  constructor(private apiService: ApiService,private http: HttpClient, private snackBar: MatSnackBar) {
  }

  ngOnInit() {

  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  searchcve() {

    this.totalitemsapi = 0;
    this.dataSource = new MatTableDataSource();
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    
    if(this.searchinput.value.length >= 3) {

      console.log('start');

      this.notfound = true;
      this.inprogress = true;
      this.progressval = 10;

      this.getdata();
    }

  }

  
  searchcvecpe() {

    this.totalitemsapi = 0;
    this.dataSource = new MatTableDataSource();
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;

    if(this.searchinputcpe.value.length >= 3) {

      this.inprogress = true;
      this.progressval = 10;

      this.apiService.getCVEbyCPE(this.searchinputcpe.value).then(respcpe => {
          
        if (respcpe) {
  
          this.parseResp(respcpe);
          this.inprogress = false;
  
        }
  
      });
    }


  }

  getdata() {

    const outvulns:any = [];
    const reqObj = new Subject<any>();
    const rateLimits = (data) => reqObj.next(data);

    reqObj.pipe(concatMap(data => of(data).pipe(delay(6000)))).subscribe(data => {
      //console.log(data);
      this.apiService.searchCVEpage(this.searchinput.value, this.default_returneditems, data.indexcve).then(resp2 => {
        
        if (resp2) {
          this.progressval = data.progressval;
          outvulns.push(resp2.vulnerabilities);
          if (data.id < Math.ceil(data.totalres/this.default_returneditems)) {
            const result = outvulns.reduce((accumulator, value) => accumulator.concat(value), []);
            data.resp.vulnerabilities = result;
            this.parseResp(data.resp);

            if(this.progressval === 100) {
              this.inprogress = false;
            }
          }

        }

      });

    });

    
    this.apiService.searchCVEpage(this.searchinput.value, this.default_returneditems, 0).then(resp => {

      if(resp.ok===false) {
        this.snackBar.open('API Response ERROR, wait 30sec and try again!', 'OK', {
          duration: 5000,
          panelClass: ['notify-snackbar-fail']
        });

        this.inprogress = false;
        this.notfound = false;
      } else {

        if (resp) {
          this.progressval = 20;
          if(resp.totalResults > this.default_returneditems) {
            let indexcve: number = 0;
            outvulns.push(resp.vulnerabilities);
  
            if(resp.totalResults > 0) {
              this.notfound = false;
            }
            const xx = 70/Math.ceil(resp.totalResults/this.default_returneditems);
            let cc = xx;
  
            for (let i = 1; i < Math.ceil(resp.totalResults/this.default_returneditems); i++) {
              cc = cc + xx;
              if(i === Math.ceil(resp.totalResults/this.default_returneditems)-1) {
                cc = 100;
              }
  
              indexcve = i * this.default_returneditems;
              rateLimits({"id":i, "resp": resp, "totalres": resp.totalResults, "indexcve": indexcve, "progressval": Math.ceil(cc)});
            }
            
          } else {
            this.parseResp(resp);
            this.inprogress = false;
          }
  
          
        }

      }


    });
    
  }


  cutlink(string) {
    const length = 70;
    const trimmedString = string.length > length ? string.substring(0, length) : string;
    return trimmedString;
  }

  parseResp(resp) {

    this.totalitemsapi = resp.totalResults;
    const vulns:any = [];


    resp.vulnerabilities.forEach(function (cve) {

      let desc = "";
      cve.cve.descriptions.forEach(function (subdesc) {
        if(subdesc.lang === 'en') {
          let string = subdesc.value;
          const length = 1000;
          const trimmedString = string.length > length ? string.substring(0, length - 3) + "..." : string;
          desc = trimmedString;
        }
      }); 

      const ref:any = [];
      cve.cve.references.forEach(function (subref) {
        if(subref.url) {
          ref.push(subref.url);
        }
      });

      let sev = "";
      let basescore = 0;
      let cvss_vector = "";


      function dor(key){
        cve.cve.metrics[key].forEach(function (submetric) {

          if(submetric.cvssData.baseSeverity) {
            sev = submetric.cvssData.baseSeverity;
          }
          if(submetric.cvssData.baseScore) {
            basescore = submetric.cvssData.baseScore;
          }
          if(submetric.cvssData.vectorString) {
            cvss_vector = submetric.cvssData.vectorString;
          }

        });
      }

      for (const key in cve.cve.metrics)
        {

          if (key === 'cvssMetricV31') {
            dor(key);
            break; //stop enum
          } else if (key === 'cvssMetricV30') {
            dor(key);
          } else if (key === 'cvssMetricV20') {
            dor(key);
          }

        }


      vulns.push({"id": cve.cve.id, "description": desc, "ref": ref, "severity": sev, "published": cve.cve.published, "cvss": basescore, "cvss_vector": cvss_vector});

    }); 
    
    this.dataSource = new MatTableDataSource(vulns);
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

}
